<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 拥挤的小人 (纯公式连续盘绕)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: sans-serif;
            user-select: none;
        }
        #info {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: white;
            pointer-events: none;
            text-shadow: 1px 1px 2px black;
            font-size: 18px;
            z-index: 10;
        }
        canvas {
            display: block;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>

    <div id="info">
        点击任意位置放置小人<br>
        <span style="font-size: 14px; opacity: 0.8">算法：r ∝ θ ∝ √n (直接计算)</span>
    </div>

    <script type="module">
        import * as THREE from 'three';

        // --- 1. 场景初始化 ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 20, 80);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 45, 45); // 稍微高一点
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(15, 30, 15);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        const planeGeometry = new THREE.PlaneGeometry(200, 200);
        const planeMaterial = new THREE.MeshStandardMaterial({ color: 0x99cc99 });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -Math.PI / 2;
        plane.receiveShadow = true;
        scene.add(plane);

        // --- 2. 游戏配置 ---
        const people = [];
        const PERSON_RADIUS = 0.8;
        const PERSON_HEIGHT = 2;
        const SPACING = 1.8; // 每个人占据的间距

        // 预先计算系数，减少实时计算量
        // 螺线增长因子 b，使得每转一圈(2PI)，半径增加一个SPACING
        const b = SPACING / (2 * Math.PI); 

        function createPerson(x, z) {
            const group = new THREE.Group();
            const bodyGeo = new THREE.CylinderGeometry(PERSON_RADIUS, PERSON_RADIUS, PERSON_HEIGHT, 16);
            const bodyMat = new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(Math.random(), 0.75, 0.5) });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = PERSON_HEIGHT / 2;
            body.castShadow = true;
            body.receiveShadow = true;
            group.add(body);

            const headGeo = new THREE.SphereGeometry(PERSON_RADIUS, 16, 16);
            const headMat = new THREE.MeshStandardMaterial({ color: 0xffccaa });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = PERSON_HEIGHT + PERSON_RADIUS * 0.8;
            head.castShadow = true;
            group.add(head);

            // 初始位置
            group.position.set(x, 10, z); // 从天上掉下来
            group.scale.set(0.1, 0.1, 0.1); // 刚开始很小
            
            scene.add(group);
            people.push({ mesh: group, targetX: x, targetZ: z });
        }

        // --- 3. 核心交互 (直接公式) ---
        window.addEventListener('pointerdown', (event) => {
            
            // 获取这是第几个人 (n)
            const n = people.length;
            
            let x = 0, z = 0;

            if (n > 0) {
                // --- 终极公式 ---
                // 计算该位置对应的总角度 theta
                // 4 * PI 是推导出来的常数，保证间距均匀
                const theta = Math.sqrt(4 * Math.PI * n);

                // 根据角度计算半径 (阿基米德螺线定义: r = b * theta)
                const r = b * theta;

                // 极坐标转笛卡尔坐标
                x = r * Math.cos(theta);
                z = r * Math.sin(theta);
            }

            // 放置小人
            createPerson(x, z);
        });

        // --- 4. 动画循环 ---
        function animate() {
            requestAnimationFrame(animate);

            people.forEach(p => {
                // 1. 下落动画
                if (p.mesh.position.y > 0) {
                    p.mesh.position.y -= 0.8;
                    if (p.mesh.position.y < 0) p.mesh.position.y = 0;
                }
                
                // 2. 变大动画
                if (p.mesh.scale.x < 1) {
                    p.mesh.scale.addScalar(0.1);
                    if(p.mesh.scale.x > 1) p.mesh.scale.set(1,1,1);
                }

                // 3. 让小人朝向 (0,0,0)
                p.mesh.lookAt(0, p.mesh.position.y, 0);
            });

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>