<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>20x20 可点格子（带圆形笔刷）</title>
  <style>
    body{margin:0;background:#111;display:flex;justify-content:center;align-items:center;height:100vh;font-family:system-ui}
    .panel{background:#fff;padding:12px;border-radius:8px;box-shadow:0 6px 24px rgba(0,0,0,0.4);width:740px}
    .top{display:flex;align-items:center;gap:12px}
    canvas{display:block;cursor:pointer;touch-action:none;margin-top:8px;border:1px solid #ddd}
    select,input{font-size:14px}
    .info{color:#666;font-size:13px}
  </style>
</head>
<body>
<div class="panel">
  <div class="top">
    <div>
      图形：
      <select id="shapeSel">
        <option value="1">1 绿色</option>
        <option value="2">2 灰色</option>
        <option value="3">3 横线</option>
        <option value="4">4 竖线</option>
        <option value="5">5 曲线 上→右</option>
        <option value="6">6 曲线 右→下</option>
        <option value="7">7 曲线 下→左</option>
        <option value="8">8 曲线 左→上</option>
        <option value="9">9 白色</option>
      </select>
    </div>

    <div>
      笔刷大小：
      <input id="brush" type="range" value="1" min="1" max="10" style="width:160px" />
      <span id="brushVal" class="info">1</span>
    </div>

    <div class="info">按住并拖动画笔（支持鼠标 / 触控 / 笔）</div>
  </div>

  <canvas id="c" width="640" height="640"></canvas>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const shapeSel = document.getElementById('shapeSel');
  const brush = document.getElementById('brush');
  const brushVal = document.getElementById('brushVal');

  const DPR = Math.max(1, window.devicePixelRatio || 1);
  const BASE = 640;
  canvas.style.width = BASE + 'px';
  canvas.style.height = BASE + 'px';
  canvas.width = Math.round(BASE * DPR);
  canvas.height = Math.round(BASE * DPR);
  ctx.scale(DPR, DPR);

  const ROWS = 20, COLS = 20;
  const cellSize = BASE / COLS;

  const state = Array.from({length:ROWS}, () => Array.from({length:COLS}, () => 1));

  function draw(){
    ctx.clearRect(0,0,BASE,BASE);

    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const s = state[r][c];
        const x = c*cellSize, y = r*cellSize;
        const cx = x + cellSize/2, cy = y + cellSize/2;

        // 填充
        if(s === 1){ ctx.fillStyle = '#2ecc71'; ctx.fillRect(x+1, y+1, cellSize-2, cellSize-2); }
        else if(s === 2){ ctx.fillStyle = '#bdc3c7'; ctx.fillRect(x+1, y+1, cellSize-2, cellSize-2); }
        else if(s === 9){ ctx.fillStyle = '#ffffff'; ctx.fillRect(x+1, y+1, cellSize-2, cellSize-2); }

        // 线条 / 曲线
        ctx.save();
        ctx.strokeStyle = '#222';
        ctx.lineWidth = Math.max(1, cellSize * 0.08);
        ctx.lineCap = 'round'; ctx.lineJoin = 'round';

        const pad = cellSize * 0.06;
        const edgeMid = side => {
          switch(side){
            case 'top': return [x + cellSize/2, y];
            case 'right': return [x + cellSize, y + cellSize/2];
            case 'bottom': return [x + cellSize/2, y + cellSize];
            case 'left': return [x, y + cellSize/2];
          }
        }

        if(s === 3){
          ctx.beginPath(); ctx.moveTo(x+pad, cy); ctx.lineTo(x+cellSize-pad, cy); ctx.stroke();
        }
        else if(s === 4){
          ctx.beginPath(); ctx.moveTo(cx, y+pad); ctx.lineTo(cx, y+cellSize-pad); ctx.stroke();
        }
        else if(s >=5 && s <=8){
          let sx,sy,ex,ey;
          if(s === 5){ [sx,sy]=edgeMid('top'); [ex,ey]=edgeMid('right'); }
          if(s === 6){ [sx,sy]=edgeMid('right'); [ex,ey]=edgeMid('bottom'); }
          if(s === 7){ [sx,sy]=edgeMid('bottom'); [ex,ey]=edgeMid('left'); }
          if(s === 8){ [sx,sy]=edgeMid('left'); [ex,ey]=edgeMid('top'); }

          if(sy === y) sy += pad; if(sy === y + cellSize) sy -= pad;
          if(sx === x) sx += pad; if(sx === x + cellSize) sx -= pad;
          if(ey === y) ey += pad; if(ey === y + cellSize) ey -= pad;
          if(ex === x) ex += pad; if(ex === x + cellSize) ex -= pad;

          ctx.beginPath();
          ctx.moveTo(sx,sy);
          ctx.quadraticCurveTo(cx,cy,ex,ey);
          ctx.stroke();
        }
        ctx.restore();
      }
    }

    ctx.strokeStyle = '#ddd'; ctx.lineWidth = 1;
    for(let i=0;i<=COLS;i++){ const x=i*cellSize+0.5; ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,BASE); ctx.stroke(); }
    for(let j=0;j<=ROWS;j++){ const y=j*cellSize+0.5; ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(BASE,y); ctx.stroke(); }
  }

  function getCellFromPointClient(clientX, clientY){
    const rect = canvas.getBoundingClientRect();
    const x = (clientX - rect.left) / rect.width * BASE;
    const y = (clientY - rect.top) / rect.height * BASE;
    return { 
      row: Math.floor(y / cellSize),
      col: Math.floor(x / cellSize),
      x, y
    };
  }

  function applyBrushAtPoint(clientX, clientY){
    const {row, col} = getCellFromPointClient(clientX, clientY);
    if(row < 0 || row >= ROWS || col < 0 || col >= COLS) return;

    const b = Math.max(1, parseInt(brush.value));
    const centerX = (col + 0.5) * cellSize;
    const centerY = (row + 0.5) * cellSize;
    const radius = b * cellSize;

    const minR = Math.max(0, Math.floor((centerY - radius) / cellSize));
    const maxR = Math.min(ROWS-1, Math.floor((centerY + radius) / cellSize));
    const minC = Math.max(0, Math.floor((centerX - radius) / cellSize));
    const maxC = Math.min(COLS-1, Math.floor((centerX + radius) / cellSize));

    for(let rr=minR; rr<=maxR; rr++){
      for(let cc=minC; cc<=maxC; cc++){
        const dx = (cc+0.5)*cellSize - centerX;
        const dy = (rr+0.5)*cellSize - centerY;
        if(Math.sqrt(dx*dx + dy*dy) <= radius - cellSize*0.5){
          state[rr][cc] = parseInt(shapeSel.value);
        }
      }
    }
  }

  let drawing = false;
  function onPointerDown(e){
    drawing = true;
    canvas.setPointerCapture?.(e.pointerId);
    applyBrushAtPoint(e.clientX, e.clientY);
    draw();
  }
  function onPointerMove(e){
    draw();
    const {x,y} = getCellFromPointClient(e.clientX,e.clientY);
    const b = Math.max(1, parseInt(brush.value));
    const radius = b*cellSize;

    ctx.save();
    ctx.beginPath();
    ctx.lineWidth = 2;
    ctx.setLineDash([6,4]);
    ctx.strokeStyle = 'red';
    ctx.arc(x,y,radius,0,Math.PI*2);
    ctx.stroke();
    ctx.restore();

    if(drawing){
      applyBrushAtPoint(e.clientX, e.clientY);
      draw();
    }
  }
  function onPointerUp(e){
    drawing = false;
    try{ canvas.releasePointerCapture?.(e.pointerId); }catch{}
  }

  canvas.addEventListener('pointerdown', onPointerDown);
  canvas.addEventListener('pointermove', onPointerMove);
  window.addEventListener('pointerup', onPointerUp);

  brush.addEventListener('input', ()=> brushVal.textContent = brush.value);

  draw();
})();
</script>
</body>
</html>
