<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>魂斗罗 (虚拟摇杆版)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #202020;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            font-family: 'Courier New', Courier, monospace;
            color: white;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none; /* 禁止浏览器默认手势 */
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            display: flex;
            justify-content: center;
            background: #000;
            border: 2px solid #444;
        }

        canvas {
            background-color: #5c94fc;
            display: block;
            width: 100%;
            height: auto;
            image-rendering: pixelated;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
            z-index: 20;
        }

        .hidden { display: none !important; }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            text-align: center;
            border: 2px solid white;
            border-radius: 10px;
            z-index: 100;
            min-width: 200px;
        }

        button.restart-btn {
            background: #e70000;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 18px;
            cursor: pointer;
            margin-top: 15px;
            border-radius: 5px;
        }

        /* --- 摇杆与按钮 UI --- */
        #controls-layer {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            height: 150px;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            padding: 0 40px;
            box-sizing: border-box;
            z-index: 50;
            pointer-events: none; /* 让空白处可以穿透 */
        }

        /* 摇杆底座 */
        #joystick-base {
            width: 100px;
            height: 100px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            position: relative;
            pointer-events: auto; /* 开启交互 */
            touch-action: none;
        }

        /* 摇杆头 */
        #joystick-stick {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none; /* 让事件穿透给 base */
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        .action-pad {
            display: flex;
            gap: 20px;
            pointer-events: auto;
            margin-bottom: 10px;
        }

        .ctrl-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            color: white;
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(4px);
            user-select: none;
            font-weight: bold;
            box-shadow: 0 4px 5px rgba(0,0,0,0.3);
            transition: transform 0.1s;
        }

        .ctrl-btn:active, .ctrl-btn.active {
            transform: scale(0.9);
            opacity: 0.8;
        }

        #btn-shoot {
            background: rgba(231, 76, 60, 0.6); /* 红色半透明 */
            border: 2px solid #c0392b;
            margin-top: 30px; /* 稍微错位 */
        }
        
        #btn-jump {
            background: rgba(46, 204, 113, 0.6); /* 绿色半透明 */
            border: 2px solid #27ae60;
            margin-bottom: 30px;
        }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="800" height="450"></canvas>
    <div id="ui">HP: <span id="hp-display">3</span> | SCORE: <span id="score-display">0</span></div>
    
    <div id="game-over" class="hidden">
        <h1 id="go-title">GAME OVER</h1>
        <p>Final Score: <span id="final-score">0</span></p>
        <button class="restart-btn" onclick="resetGame()">RESTART</button>
    </div>

    <!-- 虚拟控制器 -->
    <div id="controls-layer">
        <!-- 虚拟摇杆 -->
        <div id="joystick-base">
            <div id="joystick-stick"></div>
        </div>
        
        <!-- 动作按钮 -->
        <div class="action-pad">
            <div class="ctrl-btn" id="btn-shoot" data-key="x">S</div>
            <div class="ctrl-btn" id="btn-jump" data-key="z">J</div>
        </div>
    </div>
</div>

<script>
// --- 游戏核心逻辑保持不变，主要增加了摇杆JS部分 ---

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const uiHp = document.getElementById('hp-display');
const uiScore = document.getElementById('score-display');
const gameOverScreen = document.getElementById('game-over');
const finalScoreDisplay = document.getElementById('final-score');
const goTitle = document.getElementById('go-title');

const GRAVITY = 0.6;
const PLAYER_SPEED = 5;
const JUMP_FORCE = -13; 
const BULLET_SPEED = 12;

let keys = { ArrowLeft: false, ArrowRight: false, z: false, x: false };
let cameraX = 0;
let score = 0;
let gameRunning = true;
let player;
let bullets = [];
let enemies = [];
let platforms = [];

// 实体类定义
class Entity {
    constructor(x, y, w, h, color) {
        this.x = x; this.y = y; this.w = w; this.h = h; this.color = color;
        this.vx = 0; this.vy = 0; this.markedForDeletion = false;
    }
    draw(ctx, camX) {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x - camX, this.y, this.w, this.h);
    }
}

class Player extends Entity {
    constructor(x, y) {
        super(x, y, 30, 50, '#e70000');
        this.hp = 3;
        this.facingRight = true;
        this.onGround = false;
        this.invincibleTimer = 0;
        this.shootCooldown = 0;
    }
    update() {
        // 移动逻辑
        if (keys['ArrowRight']) { this.vx = PLAYER_SPEED; this.facingRight = true; }
        else if (keys['ArrowLeft']) { this.vx = -PLAYER_SPEED; this.facingRight = false; }
        else { this.vx = 0; }

        // 跳跃
        if (keys['z'] && this.onGround) { this.vy = JUMP_FORCE; this.onGround = false; }

        // 射击
        if (keys['x'] && this.shootCooldown <= 0) {
            this.shoot();
            this.shootCooldown = 12;
        }
        if (this.shootCooldown > 0) this.shootCooldown--;

        this.x += this.vx;
        this.y += this.vy;
        this.vy += GRAVITY;
        
        if (this.invincibleTimer > 0) this.invincibleTimer--;
        if (this.y > canvas.height + 100) this.takeDamage(3);
    }
    shoot() {
        let bx = this.facingRight ? this.x + this.w : this.x - 10;
        bullets.push(new Bullet(bx, this.y + 18, this.facingRight ? BULLET_SPEED : -BULLET_SPEED));
    }
    takeDamage(amount) {
        if (this.invincibleTimer > 0) return;
        this.hp -= amount;
        this.invincibleTimer = 60;
        uiHp.innerText = Math.max(0, this.hp);
        if (this.hp <= 0) endGame(false);
    }
    draw(ctx, camX) {
        if (this.invincibleTimer > 0 && Math.floor(Date.now() / 50) % 2 === 0) return;
        ctx.fillStyle = '#e70000'; ctx.fillRect(this.x - camX, this.y + 30, this.w, 20);
        ctx.fillStyle = '#0000e7'; ctx.fillRect(this.x - camX, this.y + 10, this.w, 20);
        ctx.fillStyle = '#f8b090'; ctx.fillRect(this.x - camX + 5, this.y, 20, 10);
        ctx.fillStyle = '#ffe0bd'; ctx.fillRect(this.x - camX + (this.facingRight?10:0), this.y + 15, 20, 8);
        ctx.fillStyle = '#333'; ctx.fillRect(this.x - camX + (this.facingRight?20:-15), this.y + 20, 25, 6);
    }
}

class Bullet extends Entity {
    constructor(x, y, vx) { super(x, y, 8, 8, 'white'); this.vx = vx; }
    update() { this.x += this.vx; if(Math.abs(this.x-cameraX)>1000) this.markedForDeletion=true; }
    draw(ctx, camX) { ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(this.x-camX+4,this.y+4,4,0,Math.PI*2); ctx.fill(); }
}

class Enemy extends Entity {
    constructor(x, y) { super(x, y, 30, 50, '#2ecc71'); this.startX=x; this.patrolDist=100; this.speed=2; this.dir=1; this.hp=2; }
    update() {
        this.x += this.speed * this.dir;
        if (Math.abs(this.x - this.startX) > this.patrolDist) this.dir *= -1;
        this.y += this.vy; this.vy += GRAVITY;
    }
    draw(ctx, camX) {
        ctx.fillStyle='#558855'; ctx.fillRect(this.x-camX,this.y,this.w,this.h);
        ctx.fillStyle='red'; ctx.fillRect(this.x-camX+(this.dir>0?20:5),this.y+10,5,5);
    }
}

class Platform extends Entity {
    constructor(x, y, w, h) { super(x, y, w, h, '#654321'); }
    draw(ctx, camX) {
        if (this.x - camX > canvas.width || this.x + this.w - camX < 0) return;
        ctx.fillStyle='#7ec850'; ctx.fillRect(this.x-camX,this.y,this.w,10);
        ctx.fillStyle='#654321'; ctx.fillRect(this.x-camX,this.y+10,this.w,this.h-10);
    }
}

// --- 碰撞与物理 ---
function checkRectCollide(r1, r2) {
    return (r1.x < r2.x + r2.w && r1.x + r1.w > r2.x && r1.y < r2.y + r2.h && r1.y + r1.h > r2.y);
}

function resolvePlatformCollisions(entity) {
    entity.onGround = false;
    for (let p of platforms) {
        if (checkRectCollide(entity, p)) {
            if (entity.vy > 0 && entity.y + entity.h - entity.vy <= p.y + 15) {
                entity.y = p.y - entity.h;
                entity.vy = 0;
                entity.onGround = true;
            }
        }
    }
}

// --- 游戏流程控制 ---
function initLevel() {
    platforms = [
        new Platform(0, 400, 2000, 50), new Platform(2200, 400, 1500, 50),
        new Platform(400, 300, 100, 20), new Platform(600, 220, 100, 20),
        new Platform(800, 300, 100, 20), new Platform(1100, 200, 400, 20),
        new Platform(1600, 300, 100, 20), new Platform(3600, 200, 50, 250)
    ];
    enemies = []; bullets = [];
    [600, 1200, 1400, 1900, 2300, 2600, 2900].forEach(x => enemies.push(new Enemy(x, 350)));
    enemies.push(new Enemy(1200, 150));

    player = new Player(50, 300);
    cameraX = 0; score = 0; gameRunning = true;
    uiScore.innerText = 0; uiHp.innerText = player.hp;
    
    gameOverScreen.classList.add('hidden');
}

function update() {
    if (!gameRunning) return;
    player.update();
    resolvePlatformCollisions(player);
    cameraX = Math.max(0, player.x - canvas.width * 0.3);

    // 更新子弹
    for (let i=bullets.length-1; i>=0; i--) {
        bullets[i].update();
        if (bullets[i].markedForDeletion) bullets.splice(i, 1);
    }
    // 更新敌人
    for (let i=enemies.length-1; i>=0; i--) {
        let e = enemies[i];
        e.update();
        resolvePlatformCollisions(e);
        if (checkRectCollide(player, e)) player.takeDamage(1);
        for (let b of bullets) {
            if (!b.markedForDeletion && !e.markedForDeletion && checkRectCollide(b, e)) {
                b.markedForDeletion = true; e.hp--;
                if (e.hp <= 0) { e.markedForDeletion = true; score += 100; uiScore.innerText = score; }
            }
        }
        if (e.x < cameraX - 200) e.markedForDeletion = true;
        if (e.markedForDeletion) enemies.splice(i, 1);
    }
    if (player.x > 3600) endGame(true);
}

function draw() {
    ctx.fillStyle = '#5c94fc'; ctx.fillRect(0, 0, canvas.width, canvas.height);
    // 视差背景
    ctx.fillStyle = 'rgba(255,255,255,0.4)'; 
    ctx.fillRect(200 - cameraX*0.1, 50, 100, 30); ctx.fillRect(600 - cameraX*0.1, 100, 150, 40);
    
    platforms.forEach(p => p.draw(ctx, cameraX));
    enemies.forEach(e => e.draw(ctx, cameraX));
    bullets.forEach(b => b.draw(ctx, cameraX));
    player.draw(ctx, cameraX);
}

function endGame(win) {
    gameRunning = false;
    gameOverScreen.classList.remove('hidden');
    finalScoreDisplay.innerText = score;
    goTitle.innerText = win ? "MISSION CLEAR" : "GAME OVER";
    goTitle.style.color = win ? "#00ff00" : "#ff0000";
}

function resetGame() { initLevel(); }

// --- 输入处理 (摇杆 + 按钮 + 键盘) ---

// 1. 键盘支持
window.addEventListener('keydown', e => {
    keys[e.key]=true; 
    if(e.key.startsWith('Arrow')) keys[e.key]=true; 
});
window.addEventListener('keyup', e => {
    keys[e.key]=false; 
    if(e.key.startsWith('Arrow')) keys[e.key]=false;
});

// 2. 动作按钮 (Jump/Shoot)
document.querySelectorAll('.ctrl-btn').forEach(btn => {
    const handleStart = (e) => { e.preventDefault(); keys[btn.dataset.key]=true; btn.classList.add('active'); };
    const handleEnd = (e) => { e.preventDefault(); keys[btn.dataset.key]=false; btn.classList.remove('active'); };
    
    btn.addEventListener('mousedown', handleStart);
    btn.addEventListener('mouseup', handleEnd);
    btn.addEventListener('touchstart', handleStart, {passive:false});
    btn.addEventListener('touchend', handleEnd, {passive:false});
});

// 3. 虚拟摇杆逻辑 (Joystick)
const joystickBase = document.getElementById('joystick-base');
const joystickStick = document.getElementById('joystick-stick');
const maxDistance = 35; // 摇杆活动半径

let joystickActive = false;

function handleJoystickStart(e) {
    e.preventDefault();
    joystickActive = true;
    handleJoystickMove(e);
}

function handleJoystickMove(e) {
    if (!joystickActive) return;
    e.preventDefault();

    let clientX, clientY;
    if(e.touches) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
    } else {
        // 支持鼠标拖拽测试
        clientX = e.clientX;
        clientY = e.clientY;
    }

    const rect = joystickBase.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;

    const dx = clientX - centerX;
    const dy = clientY - centerY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    let moveX = dx;
    let moveY = dy;

    // 限制摇杆移动范围
    if (distance > maxDistance) {
        const angle = Math.atan2(dy, dx);
        moveX = Math.cos(angle) * maxDistance;
        moveY = Math.sin(angle) * maxDistance;
    }

    joystickStick.style.transform = `translate(calc(-50% + ${moveX}px), calc(-50% + ${moveY}px))`;

    // 判断左右方向阈值
    if (moveX > 10) {
        keys['ArrowRight'] = true;
        keys['ArrowLeft'] = false;
    } else if (moveX < -10) {
        keys['ArrowLeft'] = true;
        keys['ArrowRight'] = false;
    } else {
        keys['ArrowLeft'] = false;
        keys['ArrowRight'] = false;
    }
}

function handleJoystickEnd(e) {
    e.preventDefault();
    joystickActive = false;
    joystickStick.style.transform = `translate(-50%, -50%)`; // 回正
    keys['ArrowLeft'] = false;
    keys['ArrowRight'] = false;
}

// 绑定摇杆事件 (兼容触摸和鼠标)
joystickBase.addEventListener('touchstart', handleJoystickStart, {passive:false});
joystickBase.addEventListener('touchmove', handleJoystickMove, {passive:false});
joystickBase.addEventListener('touchend', handleJoystickEnd, {passive:false});

// 鼠标兼容
joystickBase.addEventListener('mousedown', handleJoystickStart);
window.addEventListener('mousemove', handleJoystickMove); // 监听window防止鼠标滑出base
window.addEventListener('mouseup', handleJoystickEnd);


// 启动游戏
initLevel();
function loop() { update(); draw(); requestAnimationFrame(loop); }
loop();

</script>
</body>
</html>