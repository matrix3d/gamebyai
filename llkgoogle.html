<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>è¿è¿çœ‹</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
    body {
        font-family: Arial, sans-serif;
        background-color: #f0f0f0;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        margin: 0;
    }
    
    .game-container {
        background-color: #fff;
        border-radius: 8px;
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        padding: 20px;
        user-select: none; /* Prevent text selection during drag */
    }
    
    .game-header {
        text-align: center;
        margin-bottom: 20px;
    }
    
    .score-panel {
        display: flex;
        justify-content: space-between;
        margin-bottom: 10px;
    }
    
    .score, .time {
        font-size: 16px;
    }
    
    .game-board {
        display: grid;
        grid-gap: 2px; /* Spacing between tiles */
        background-color: #ccc; /* Background for gaps */
        padding: 2px; /* Padding around the grid */
        border-radius: 4px;
    }
    
    .game-tile {
        width: 40px;
        height: 40px;
        background-color: #e0e0e0;
        border-radius: 4px;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 24px;
        cursor: pointer;
        user-select: none; /* Prevent text selection on tiles */
        transition: border-color 0.1s ease; /* æ·»åŠ è¾¹æ¡†é¢œè‰²è¿‡æ¸¡ï¼Œä½¿ç‚¹å‡»æ•ˆæœæ›´å¹³æ»‘ */
    }
    
    .game-tile:hover {
        background-color: #d0d0d0; /* é¼ æ ‡æ‚¬åœæ—¶ç¨å¾®æ”¹å˜èƒŒæ™¯é¢œè‰² */
    }
    
    .game-tile.selected {
        border: 2px solid #007bff;
        /* ç¡®ä¿ .selected æ ·å¼åªä¿®æ”¹è¾¹æ¡†ï¼Œä¸å½±å“å¤§å° */
    }
    
    .game-tile.matched {
        visibility: hidden; /* éšè—å·²åŒ¹é…çš„æ–¹å— */
    }
    
    .control-panel {
        text-align: center;
        margin-top: 20px;
    }
    
    button {
        padding: 10px 20px;
        border: none;
        border-radius: 4px;
        background-color: #007bff;
        color: white;
        cursor: pointer;
        font-size: 16px;
        transition: background-color 0.2s ease; /* æ·»åŠ æŒ‰é’®èƒŒæ™¯é¢œè‰²è¿‡æ¸¡æ•ˆæœ */
    }
    
    button:hover {
        background-color: #0056b3;
    }
    
    button:disabled {
        background-color: #999;
        cursor: default;
    }
    
    button:disabled:hover {
        background-color: #999; /* ç¦ç”¨çŠ¶æ€é¼ æ ‡æ‚¬åœé¢œè‰²ä¿æŒä¸€è‡´ */
    }
    
    
    @media (max-width: 600px) {
        .game-tile {
            width: 30px;
            height: 30px;
            font-size: 20px;
        }
    }
    </style>
</head>
<body>
<div class="game-container">
    <div class="game-header">
        <h1>è¿è¿çœ‹</h1>
    </div>
    <div class="score-panel">
        <div class="score">å¾—åˆ†: <span id="score">0</span></div>
        <div class="time">æ—¶é—´: <span id="time">00:00</span></div>
    </div>
    <div class="game-board" id="gameBoard">
        </div>
    <div class="control-panel">
        <button id="startButton">å¼€å§‹æ¸¸æˆ</button>
        <button id="resetButton" disabled>é‡æ–°å¼€å§‹</button>
    </div>
</div>

<script>
const gameBoard = document.getElementById('gameBoard');
const scoreDisplay = document.getElementById('score');
const timeDisplay = document.getElementById('time');
const startButton = document.getElementById('startButton');
const resetButton = document.getElementById('resetButton');

let tiles = [];
let gridSize = { rows: 6, cols: 8 }; // å¯è°ƒæ•´ç½‘æ ¼å¤§å°ï¼Œæ›´æ”¹æ¸¸æˆéš¾åº¦æˆ–é€‚åº”å±å¹•
let selectedTiles = [];
let score = 0;
let gameStarted = false;
let timerInterval;
let timeLeft = 600; // æ¸¸æˆæ—¶é—´ï¼Œå•ä½ç§’ï¼Œå¯è°ƒæ•´

// å¢åŠ æ›´å¤šç¬¦å·ï¼Œç¡®ä¿ç½‘æ ¼å¤§å°å’Œç¬¦å·ç§ç±»å……è¶³
const tileSymbols = [
    'ğŸ‡', 'ğŸ‰', 'ğŸŒ', 'ğŸ', 'ğŸŠ', 'ğŸ‹', 'ğŸ¥', 'ğŸ“',
    'ğŸ’', 'ğŸ‘', 'ğŸ¥­', 'ğŸ', 'ğŸ¥‘', 'ğŸ¥•', 'ğŸ¥¦', 'ğŸ„',
    'ğŸ”', 'ğŸ•', 'ğŸŸ', 'ğŸŒ­', 'ğŸ¥ª', 'ğŸŒ®', 'ğŸ£', 'ğŸ¦',
    'ğŸ©', 'ğŸª', 'ğŸ«', 'ğŸ¬', 'ğŸ¿', 'ğŸŒ°', 'ğŸ¥œ', 'ğŸ¯',
    'â¤ï¸', 'ğŸŒŸ', 'ğŸŒˆ', 'â˜€ï¸', 'ğŸŒ™', 'ğŸŒ¸', 'ğŸŒº', 'ğŸŒ»',
    'ğŸ¶', 'ğŸ±', 'ğŸ»', 'ğŸ¼', 'ğŸ¦Š', 'ğŸ¨', 'ğŸ¯', 'ğŸ¦'
]; // ç°åœ¨æœ‰ 64 ä¸ªç¬¦å·ï¼Œè¿œè¶… 6x8 ç½‘æ ¼æ‰€éœ€ (24ä¸ª)ï¼Œæä¾›æ›´ä¸°å¯Œçš„é€‰æ‹©

startButton.addEventListener('click', startGame);
resetButton.addEventListener('click', resetGame);

function startGame() {
    if (!gameStarted) {
        gameStarted = true;
        startButton.disabled = true;
        resetButton.disabled = false;
        score = 0;
        scoreDisplay.textContent = score;
        timeLeft = 60; // é‡ç½®æ—¶é—´
        timeDisplay.textContent = formatTime(timeLeft);
        clearInterval(timerInterval); // æ¸…é™¤ä¹‹å‰çš„è®¡æ—¶å™¨
        timerInterval = setInterval(updateTimer, 1000); // å¯åŠ¨æ–°çš„è®¡æ—¶å™¨
        generateTiles();
        renderBoard();
    }
}

function resetGame() {
    gameStarted = false;
    startButton.disabled = false;
    resetButton.disabled = true;
    clearInterval(timerInterval);
    timeDisplay.textContent = '00:00';
    tiles = [];
    selectedTiles = [];
    score = 0;
    scoreDisplay.textContent = score;
    gameBoard.innerHTML = ''; // æ¸…ç©ºæ¸¸æˆé¢æ¿
}

function generateTiles() {
    tiles = [];
    const numPairs = (gridSize.rows * gridSize.cols) / 2;
    const symbols = [...tileSymbols].slice(0, tileSymbols.length); // å¤åˆ¶ç¬¦å·æ•°ç»„ï¼Œé¿å…ä¿®æ”¹åŸæ•°ç»„

    if (numPairs > symbols.length) {
        alert("å¯ç”¨å”¯ä¸€ç¬¦å·ä¸è¶³ä»¥å¡«å……å½“å‰ç½‘æ ¼å¤§å°ã€‚è¯·æ·»åŠ æ›´å¤šç¬¦å·æˆ–ç¼©å°ç½‘æ ¼å°ºå¯¸ã€‚");
        resetGame();
        return;
    }

    let pairs = [];
    for (let i = 0; i < numPairs; i++) {
        pairs.push(symbols[i % symbols.length]); // å¾ªç¯ä½¿ç”¨ç¬¦å·ï¼Œå¦‚æœç¬¦å·æ•°é‡å°‘äºé…å¯¹æ•°é‡
    }

    const duplicatedPairs = [...pairs, ...pairs]; // å¤åˆ¶é…å¯¹ï¼Œå¾—åˆ°å®Œæ•´çš„æ–¹å—æ•°ç»„
    // ä½¿ç”¨ Fisher-Yates ç®—æ³•æ´—ç‰Œæ•°ç»„
    for (let i = duplicatedPairs.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [duplicatedPairs[i], duplicatedPairs[j]] = [duplicatedPairs[j], duplicatedPairs[i]];
    }

    let index = 0;
    for (let row = 0; row < gridSize.rows; row++) {
        tiles[row] = [];
        for (let col = 0; col < gridSize.cols; col++) {
            tiles[row][col] = {
                symbol: duplicatedPairs[index++],
                matched: false,
                selected: false,
                row: row,
                col: col
            };
        }
    }
}


function renderBoard() {
    gameBoard.innerHTML = ''; // æ¸…ç©ºä¹‹å‰çš„æ¸¸æˆé¢æ¿å†…å®¹
    gameBoard.style.gridTemplateColumns = `repeat(${gridSize.cols}, 1fr)`; // åŠ¨æ€è®¾ç½®ç½‘æ ¼åˆ—æ•°

    for (let row = 0; row < gridSize.rows; row++) {
        for (let col = 0; col < gridSize.cols; col++) {
            const tile = tiles[row][col];
            const tileElement = document.createElement('div');
            tileElement.classList.add('game-tile');
            tileElement.textContent = tile.symbol;
            tileElement.dataset.row = row;
            tileElement.dataset.col = col;

            tileElement.addEventListener('click', handleTileClick);

            if (tile.matched) {
                tileElement.classList.add('matched');
            }
            if (tile.selected) {
                tileElement.classList.add('selected');
            }

            gameBoard.appendChild(tileElement);
        }
    }
}

function handleTileClick(event) {
    if (!gameStarted) return;

    const tileElement = event.target;
    const row = parseInt(tileElement.dataset.row);
    const col = parseInt(tileElement.dataset.col);
    const clickedTile = tiles[row][col];

    if (clickedTile.matched || clickedTile.selected) return; // å¿½ç•¥å·²åŒ¹é…æˆ–å·²é€‰ä¸­çš„æ–¹å—

    clickedTile.selected = true;
    tileElement.classList.add('selected');
    selectedTiles.push(clickedTile);

    if (selectedTiles.length === 2) {
        const [tile1, tile2] = selectedTiles;
        if (tile1.symbol === tile2.symbol) {
            if (canConnect(tile1, tile2)) {
                score += 10; // å¢åŠ å¾—åˆ†
                scoreDisplay.textContent = score;
                tile1.matched = true;
                tile2.matched = true;
                updateBoardForMatch(tile1, tile2);
                checkGameWin();
            } else {
                setTimeout(() => {
                    resetSelection();
                }, 500); // çŸ­æš‚å»¶æ—¶åé‡ç½®é€‰æ‹©
            }
        } else {
            setTimeout(() => {
                resetSelection();
            }, 500); // çŸ­æš‚å»¶æ—¶åé‡ç½®é€‰æ‹©
        }
    } else if (selectedTiles.length > 2) {
        resetSelection();
        clickedTile.selected = true;
        tileElement.classList.add('selected');
        selectedTiles.push(clickedTile);
    }
}

function updateBoardForMatch(tile1, tile2) {
    const tileElement1 = gameBoard.children[tile1.row * gridSize.cols + tile1.col];
    const tileElement2 = gameBoard.children[tile2.row * gridSize.cols + tile2.col];
    tileElement1.classList.add('matched');
    tileElement2.classList.add('matched');
    resetSelection(); // åŒ¹é…åæ¸…é™¤é€‰æ‹©çŠ¶æ€
}


function resetSelection() {
    selectedTiles.forEach(tile => {
        tile.selected = false;
        const tileElement = gameBoard.children[tile.row * gridSize.cols + tile.col];
        if(tileElement) { // æ£€æŸ¥å…ƒç´ æ˜¯å¦ä»ç„¶åœ¨ DOM ä¸­ (å¯èƒ½å·²è¢«åŒ¹é…ç§»é™¤)
            tileElement.classList.remove('selected');
        }
    });
    selectedTiles = [];
}


function canConnect(tile1, tile2) {
    if (tile1 === tile2) return false; // ä¸èƒ½è¿æ¥è‡ªèº«

    // æ£€æŸ¥ä¸¤ä¸ªæ–¹å—æ˜¯å¦åœ¨åŒä¸€è¡Œæˆ–åŒä¸€åˆ—ï¼Œä¸”ä¹‹é—´æ²¡æœ‰å…¶ä»–æœªæ¶ˆé™¤çš„æ–¹å—
    if (tile1.row === tile2.row) { // åŒä¸€è¡Œ
        if (isStraightLineClear(tile1, tile2, 'row')) { // ä½¿ç”¨æ›´å‡†ç¡®çš„å‡½æ•°å
            return true;
        }
    }
    if (tile1.col === tile2.col) { // åŒä¸€åˆ—
        if (isStraightLineClear(tile1, tile2, 'col')) { // ä½¿ç”¨æ›´å‡†ç¡®çš„å‡½æ•°å
            return true;
        }
    }

    // æ£€æŸ¥å•æŠ˜çº¿è¿æ¥
    if (isSingleLineCornerClear(tile1, tile2)) {
        return true;
    }

    // æ£€æŸ¥åŒæŠ˜çº¿è¿æ¥ (æœ€å¤šå…è®¸ä¸¤ä¸ªæ‹è§’)
    if (isDoubleLineCornerClear(tile1, tile2)) {
        return true;
    }


    return false; // æ²¡æœ‰æ‰¾åˆ°æœ‰æ•ˆè¿æ¥è·¯å¾„
}

function isStraightLineClear(tile1, tile2, orientation) { // æ›´å‡†ç¡®çš„å‡½æ•°å
    if (orientation === 'row') {
        const row = tile1.row;
        const startCol = Math.min(tile1.col, tile2.col) + 1;
        const endCol = Math.max(tile1.col, tile2.col);
        for (let col = startCol; col < endCol; col++) {
            if (tiles[row][col].matched === false) {
                return false; // è·¯å¾„ä¸Šæœ‰æœªæ¶ˆé™¤çš„æ–¹å—ï¼Œä¸é€š
            }
        }
        return true; // ç›´çº¿è·¯å¾„ä¸Šæ²¡æœ‰éšœç¢ç‰©ï¼Œå¯è¿æ¥
    } else if (orientation === 'col') {
        const col = tile1.col;
        const startRow = Math.min(tile1.row, tile2.row) + 1;
        const endRow = Math.max(tile1.row, tile2.row);
        for (let row = startRow; row < endRow; row++) {
            if (tiles[row][col].matched === false) {
                return false; // è·¯å¾„ä¸Šæœ‰æœªæ¶ˆé™¤çš„æ–¹å—ï¼Œä¸é€š
            }
        }
        return true; // ç›´çº¿è·¯å¾„ä¸Šæ²¡æœ‰éšœç¢ç‰©ï¼Œå¯è¿æ¥
    }
    return false; // orientation å‚æ•°é”™è¯¯
}


function isSingleLineCornerClear(tile1, tile2) {
    const cornerTile1 = tiles[tile1.row][tile2.col]; // ç¬¬ä¸€ä¸ªæ‹è§’ç‚¹
    const cornerTile2 = tiles[tile2.row][tile1.col]; // ç¬¬äºŒä¸ªæ‹è§’ç‚¹

    // æƒ…å†µ1: tile1 -> cornerTile1 -> tile2  (æ¨ªå‘å†çºµå‘)
    if (cornerTile1.matched !== false) { // è§’è½æ–¹å—å¿…é¡»æ˜¯ç©ºçš„ (å·²åŒ¹é…)
        if (isStraightLineClear(tile1, cornerTile1, 'row') && isStraightLineClear(cornerTile1, tile2, 'col')) {
            return true;
        }
    }
    // æƒ…å†µ2: tile1 -> cornerTile2 -> tile2  (çºµå‘å†æ¨ªå‘)
    if (cornerTile2.matched !== false) { // è§’è½æ–¹å—å¿…é¡»æ˜¯ç©ºçš„ (å·²åŒ¹é…)
        if (isStraightLineClear(tile1, cornerTile2, 'col') && isStraightLineClear(cornerTile2, tile2, 'row')) {
            return true;
        }
    }
    return false; // æ²¡æœ‰å•æŠ˜çº¿è·¯å¾„
}


function isDoubleLineCornerClear(tile1, tile2) {
    for (let row = 0; row < gridSize.rows; row++) { // éå†æ‰€æœ‰å¯èƒ½çš„ä¸­é—´è¡Œ
        for (let col = 0; col < gridSize.cols; col++) { // éå†æ‰€æœ‰å¯èƒ½çš„ä¸­é—´åˆ—
            const cornerTile1 = tiles[tile1.row][col]; // ç¬¬ä¸€ä¸ªå¯èƒ½çš„æ‹è§’ç‚¹
            const cornerTile2 = tiles[row][tile2.col]; // ç¬¬äºŒä¸ªå¯èƒ½çš„æ‹è§’ç‚¹

            if (cornerTile1.matched !== false && cornerTile2.matched !== false) { // ä¸¤ä¸ªè§’è½ç‚¹éƒ½å¿…é¡»æ˜¯ç©ºçš„
                if (isStraightLineClear(tile1, cornerTile1, 'row') &&
                    isStraightLineClear(cornerTile1, cornerTile2, 'col') &&
                    isStraightLineClear(cornerTile2, tile2, 'row')) {
                    return true; // æ‰¾åˆ°åŒæŠ˜çº¿è·¯å¾„ (æ¨ª-çºµ-æ¨ª)
                }
            }

            const cornerTile3 = tiles[row][tile1.col]; // ç¬¬ä¸‰ä¸ªå¯èƒ½çš„æ‹è§’ç‚¹
            const cornerTile4 = tiles[tile2.row][col]; // ç¬¬å››ä¸ªå¯èƒ½çš„æ‹è§’ç‚¹

             if (cornerTile3.matched !== false && cornerTile4.matched !== false) { // ä¸¤ä¸ªè§’è½ç‚¹éƒ½å¿…é¡»æ˜¯ç©ºçš„
                if (isStraightLineClear(tile1, cornerTile3, 'col') &&
                    isStraightLineClear(cornerTile3, cornerTile4, 'row') &&
                    isStraightLineClear(cornerTile4, tile2, 'col')) {
                    return true; // æ‰¾åˆ°åŒæŠ˜çº¿è·¯å¾„ (çºµ-æ¨ª-çºµ)
                }
            }
        }
    }
    return false; // æ²¡æœ‰åŒæŠ˜çº¿è·¯å¾„
}



function checkGameWin() {
    let allMatched = true;
    for (let row = 0; row < gridSize.rows; row++) {
        for (let col = 0; col < gridSize.cols; col++) {
            if (!tiles[row][col].matched) {
                allMatched = false;
                break;
            }
        }
        if (!allMatched) break;
    }

    if (allMatched) {
        gameWin();
    }
}

function gameWin() {
    gameStarted = false;
    clearInterval(timerInterval);
    startButton.disabled = false;
    resetButton.disabled = false;
    alert(`æ­å–œä½ ï¼Œæ¸¸æˆèƒœåˆ©ï¼ å¾—åˆ†: ${score}`);
}


function updateTimer() {
    timeLeft--;
    timeDisplay.textContent = formatTime(timeLeft);

    if (timeLeft <= 0) {
        clearInterval(timerInterval);
        gameOver();
    }
}

function formatTime(seconds) {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return `${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}`;
}

function gameOver() {
    gameStarted = false;
    clearInterval(timerInterval);
    startButton.disabled = false;
    resetButton.disabled = false;
    alert(`æ—¶é—´åˆ°ï¼æ¸¸æˆç»“æŸã€‚ å¾—åˆ†: ${score}`);
}

resetGame(); // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–æ¸¸æˆçŠ¶æ€
</script>
